/**
 * Copyright 2014-2019 David Herron
 *
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.process1 = exports.processAsync = exports.process = exports.parse = exports.logPerformance = exports.logProcessing = exports.setTracePerformance = exports.setTraceProcessing = exports.config = exports.PageProcessor = exports.Munger = exports.MahafuncArray = exports.ElementTweaker = exports.CustomElement = exports.Mahafunc = void 0;
const cheerio = __importStar(require("cheerio"));
var Mahafunc_1 = require("./Mahafunc");
Object.defineProperty(exports, "Mahafunc", { enumerable: true, get: function () { return Mahafunc_1.Mahafunc; } });
var CustomElement_1 = require("./CustomElement");
Object.defineProperty(exports, "CustomElement", { enumerable: true, get: function () { return CustomElement_1.CustomElement; } });
var ElementTweaker_1 = require("./ElementTweaker");
Object.defineProperty(exports, "ElementTweaker", { enumerable: true, get: function () { return ElementTweaker_1.ElementTweaker; } });
var MahafuncArray_1 = require("./MahafuncArray");
Object.defineProperty(exports, "MahafuncArray", { enumerable: true, get: function () { return MahafuncArray_1.MahafuncArray; } });
var Munger_1 = require("./Munger");
Object.defineProperty(exports, "Munger", { enumerable: true, get: function () { return Munger_1.Munger; } });
var PageProcessor_1 = require("./PageProcessor");
Object.defineProperty(exports, "PageProcessor", { enumerable: true, get: function () { return PageProcessor_1.PageProcessor; } });
const MahafuncArray_2 = require("./MahafuncArray");
let configCheerio;
let traceFlag = false;
let tracePerf = false;
/**
 * Set the Cheerio configuration.
 * @param _configCheerio Object corresponding to Cheerio documentation
 * @see {@link https://www.npmjs.com/package/cheerio} for Cheerio documentation
 */
function config(_configCheerio) {
    configCheerio = _configCheerio;
}
exports.config = config;
/**
 * Enable or disable "processing" tracing.  Controls whether `logProcessing` does anything.
 * @param _traceFlag
 */
function setTraceProcessing(_traceFlag) {
    traceFlag = _traceFlag;
}
exports.setTraceProcessing = setTraceProcessing;
/**
 * Enable or disable "performance" tracing.
 * @param _traceFlag
 */
function setTracePerformance(_traceFlag) {
    tracePerf = _traceFlag;
}
exports.setTracePerformance = setTracePerformance;
/**
 * Perform "processing" tracing, if enabled.
 * @param text
 * @returns
 */
function logProcessing(text) {
    if (!traceFlag)
        return;
    console.log(text);
}
exports.logProcessing = logProcessing;
/**
 * Perform "performance" tracing, if enabled.
 * @param start
 * @param text
 * @returns
 */
function logPerformance(start, text) {
    if (!tracePerf)
        return;
    // https://stackoverflow.com/questions/14980014/how-can-i-calculate-the-time-between-2-dates-in-typescript
    console.log(`${text} ${(new Date().getTime() - start.getTime()) / 1000} seconds`);
}
exports.logPerformance = logPerformance;
/**
 * Parse the supplied text using Cheerio.   If a Cheerio Config
 * has been set, it will be used.
 *
 * @param text The HTML text to parse
 * @returns The object returned by Cheerio
 */
function parse(text) {
    return configCheerio
        ? cheerio.load(text, configCheerio)
        : cheerio.load(text);
}
exports.parse = parse;
;
/**
 * Process an array of functions against HTML text.  This
 * function supports both Promise/async and Callback execution.
 * It uses {@link processAsync} for the processing and it
 * always returns the Promise generated by that function.  If
 * the callback function is supplied in `done`, then it is called.
 *
 * @param text The HTML text to process
 * @param metadata Metadata object provided by the application and passed through to functions
 * @param mahabhutaFuncs The array of functions
 * @param done Optional callback function to call when processing is finished
 * @returns The Promise generated from processAsync
 */
async function process(text, metadata, mahabhutaFuncs, done) {
    let ret = processAsync(text, metadata, mahabhutaFuncs);
    if (done) {
        ret.then(html => { done(undefined, html); })
            .catch(err => { done(err); });
    }
    return ret;
}
exports.process = process;
/**
 * Process the text using functions supplied in the array mahabhutaFuncs.
 */
async function processAsync(text, metadata, mahabhutaFuncs) {
    if (!mahabhutaFuncs || mahabhutaFuncs.length < 0)
        mahabhutaFuncs = [];
    let cleanOrDirty = 'first-time';
    // console.log(`processAsync text at start ${text}`);
    // Allow a pre-parsed context to be passed in
    const $ = typeof text === 'function' ? text : parse(text);
    // console.log(`processAsync $ at start `, $.html());
    // const loops = [];
    do {
        // let startProcessing = new Date();
        let mhObj;
        if (Array.isArray(mahabhutaFuncs)) {
            // console.log(`ARRAY substitution`);
            mhObj = new MahafuncArray_2.MahafuncArray("master", {});
            mhObj.setMahafuncArray(mahabhutaFuncs);
        }
        else if (mahabhutaFuncs instanceof MahafuncArray_2.MahafuncArray) {
            // console.log(`MahafuncArray`);
            mhObj = mahabhutaFuncs;
        }
        else
            throw new Error(`Bad mahabhutaFuncs object supplied`);
        cleanOrDirty = 'clean';
        /* let results = */ await mhObj.process($, metadata, () => { cleanOrDirty = 'dirty'; });
        // results.forEach(result => { loops.push(mhObj.name +'  '+ result); });
        // console.log(`MAHABHUTA processAsync ${metadata.document.path} FINISH ${(new Date() - startProcessing) / 1000} seconds ${cleanOrDirty}`);
    } while (cleanOrDirty === 'dirty');
    // loops.forEach(l => { console.log(l); });
    return $.html();
}
exports.processAsync = processAsync;
/**
 * Process one function against the supplied text.
 *
 * @param text The text to process
 * @param metadata Metadata object provided by the application and passed through to functions
 * @param mahafunc A single function, or a {@link MahafuncArray}, to execute
 * @param done Optional callback function to call when processing is finished
 * @returns The Promise generated from processAsync
 */
async function process1(text, metadata, mahafunc, done) {
    return process(text, metadata, [mahafunc], done);
}
exports.process1 = process1;
/**
 * Construct a MahafuncArray
 * @param name The name for the array
 * @param config Configuration object
 * @param functions An optional list of functions to add
 * @returns A MahafuncArray
 */
function default_1(name, config, functions) {
    const array = new MahafuncArray_2.MahafuncArray(name, config);
    if (functions)
        array.addMahafunc(functions);
    return array;
}
exports.default = default_1;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9saWIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJHO0FBRUgsWUFBWSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRWIsaURBQW1DO0FBR25DLHVDQUFzQztBQUE3QixvR0FBQSxRQUFRLE9BQUE7QUFDakIsaURBQWdEO0FBQXZDLDhHQUFBLGFBQWEsT0FBQTtBQUN0QixtREFBa0Q7QUFBekMsZ0hBQUEsY0FBYyxPQUFBO0FBQ3ZCLGlEQUE4RDtBQUFyRCw4R0FBQSxhQUFhLE9BQUE7QUFDdEIsbUNBQWtDO0FBQXpCLGdHQUFBLE1BQU0sT0FBQTtBQUNmLGlEQUFnRDtBQUF2Qyw4R0FBQSxhQUFhLE9BQUE7QUFHdEIsbURBQThEO0FBRTlELElBQUksYUFBYSxDQUFDO0FBQ2xCLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztBQUN0QixJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFFdEI7Ozs7R0FJRztBQUNILFNBQWdCLE1BQU0sQ0FBQyxjQUFjO0lBQ2pDLGFBQWEsR0FBRyxjQUFjLENBQUM7QUFDbkMsQ0FBQztBQUZELHdCQUVDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQUMsVUFBbUI7SUFDbEQsU0FBUyxHQUFHLFVBQVUsQ0FBQztBQUMzQixDQUFDO0FBRkQsZ0RBRUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxVQUFtQjtJQUNuRCxTQUFTLEdBQUcsVUFBVSxDQUFDO0FBQzNCLENBQUM7QUFGRCxrREFFQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixhQUFhLENBQUMsSUFBWTtJQUN0QyxJQUFJLENBQUMsU0FBUztRQUFFLE9BQU87SUFDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN0QixDQUFDO0FBSEQsc0NBR0M7QUFFRDs7Ozs7R0FLRztB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LFFBQVEsRUFDdEIsUUFBc0IsRUFDdEIsSUFBZTtJQUV2QixPQUFPLE9BQU8sQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUUsUUFBUSxDQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDdkQsQ0FBQztBQU5ELDRCQU1DO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsbUJBQ1EsSUFBWSxFQUFFLE1BQWMsRUFBRSxTQUF3QjtJQUMxRCxNQUFNLEtBQUssR0FBRyxJQUFJLDZCQUFhLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLElBQUksU0FBUztRQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDNUMsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUxELDRCQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE5IERhdmlkIEhlcnJvblxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICogYXMgY2hlZXJpbyBmcm9tICdjaGVlcmlvJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5cbmV4cG9ydCB7IE1haGFmdW5jIH0gZnJvbSAnLi9NYWhhZnVuYyc7XG5leHBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi9DdXN0b21FbGVtZW50JztcbmV4cG9ydCB7IEVsZW1lbnRUd2Vha2VyIH0gZnJvbSAnLi9FbGVtZW50VHdlYWtlcic7XG5leHBvcnQgeyBNYWhhZnVuY0FycmF5LCBNYWhhZnVuY1R5cGUgfSBmcm9tICcuL01haGFmdW5jQXJyYXknO1xuZXhwb3J0IHsgTXVuZ2VyIH0gZnJvbSAnLi9NdW5nZXInO1xuZXhwb3J0IHsgUGFnZVByb2Nlc3NvciB9IGZyb20gJy4vUGFnZVByb2Nlc3Nvcic7XG5cbmltcG9ydCB7IE1haGFmdW5jIH0gZnJvbSAnLi9NYWhhZnVuYyc7XG5pbXBvcnQgeyBNYWhhZnVuY0FycmF5LCBNYWhhZnVuY1R5cGUgfSBmcm9tICcuL01haGFmdW5jQXJyYXknO1xuXG5sZXQgY29uZmlnQ2hlZXJpbztcbmxldCB0cmFjZUZsYWcgPSBmYWxzZTtcbmxldCB0cmFjZVBlcmYgPSBmYWxzZTtcblxuLyoqXG4gKiBTZXQgdGhlIENoZWVyaW8gY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSBfY29uZmlnQ2hlZXJpbyBPYmplY3QgY29ycmVzcG9uZGluZyB0byBDaGVlcmlvIGRvY3VtZW50YXRpb25cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2NoZWVyaW99IGZvciBDaGVlcmlvIGRvY3VtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZyhfY29uZmlnQ2hlZXJpbykge1xuICAgIGNvbmZpZ0NoZWVyaW8gPSBfY29uZmlnQ2hlZXJpbztcbn1cblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBcInByb2Nlc3NpbmdcIiB0cmFjaW5nLiAgQ29udHJvbHMgd2hldGhlciBgbG9nUHJvY2Vzc2luZ2AgZG9lcyBhbnl0aGluZy5cbiAqIEBwYXJhbSBfdHJhY2VGbGFnIFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhY2VQcm9jZXNzaW5nKF90cmFjZUZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0cmFjZUZsYWcgPSBfdHJhY2VGbGFnO1xufVxuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIFwicGVyZm9ybWFuY2VcIiB0cmFjaW5nLlxuICogQHBhcmFtIF90cmFjZUZsYWcgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFjZVBlcmZvcm1hbmNlKF90cmFjZUZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0cmFjZVBlcmYgPSBfdHJhY2VGbGFnO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gXCJwcm9jZXNzaW5nXCIgdHJhY2luZywgaWYgZW5hYmxlZC5cbiAqIEBwYXJhbSB0ZXh0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dQcm9jZXNzaW5nKHRleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdHJhY2VGbGFnKSByZXR1cm47XG4gICAgY29uc29sZS5sb2codGV4dCk7XG59XG5cbi8qKlxuICogUGVyZm9ybSBcInBlcmZvcm1hbmNlXCIgdHJhY2luZywgaWYgZW5hYmxlZC5cbiAqIEBwYXJhbSBzdGFydCBcbiAqIEBwYXJhbSB0ZXh0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dQZXJmb3JtYW5jZShzdGFydDogRGF0ZSwgdGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCF0cmFjZVBlcmYpIHJldHVybjtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDk4MDAxNC9ob3ctY2FuLWktY2FsY3VsYXRlLXRoZS10aW1lLWJldHdlZW4tMi1kYXRlcy1pbi10eXBlc2NyaXB0XG4gICAgY29uc29sZS5sb2coYCR7dGV4dH0gJHsobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gMTAwMH0gc2Vjb25kc2ApXG59XG5cbi8qKlxuICogUGFyc2UgdGhlIHN1cHBsaWVkIHRleHQgdXNpbmcgQ2hlZXJpby4gICBJZiBhIENoZWVyaW8gQ29uZmlnIFxuICogaGFzIGJlZW4gc2V0LCBpdCB3aWxsIGJlIHVzZWQuXG4gKiBcbiAqIEBwYXJhbSB0ZXh0IFRoZSBIVE1MIHRleHQgdG8gcGFyc2VcbiAqIEByZXR1cm5zIFRoZSBvYmplY3QgcmV0dXJuZWQgYnkgQ2hlZXJpb1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UodGV4dDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbmZpZ0NoZWVyaW8gXG4gICAgICAgICAgICA/IGNoZWVyaW8ubG9hZCh0ZXh0LCBjb25maWdDaGVlcmlvKVxuICAgICAgICAgICAgOiBjaGVlcmlvLmxvYWQodGV4dCk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYW4gYXJyYXkgb2YgZnVuY3Rpb25zIGFnYWluc3QgSFRNTCB0ZXh0LiAgVGhpc1xuICogZnVuY3Rpb24gc3VwcG9ydHMgYm90aCBQcm9taXNlL2FzeW5jIGFuZCBDYWxsYmFjayBleGVjdXRpb24uXG4gKiBJdCB1c2VzIHtAbGluayBwcm9jZXNzQXN5bmN9IGZvciB0aGUgcHJvY2Vzc2luZyBhbmQgaXRcbiAqIGFsd2F5cyByZXR1cm5zIHRoZSBQcm9taXNlIGdlbmVyYXRlZCBieSB0aGF0IGZ1bmN0aW9uLiAgSWZcbiAqIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBzdXBwbGllZCBpbiBgZG9uZWAsIHRoZW4gaXQgaXMgY2FsbGVkLlxuICogXG4gKiBAcGFyYW0gdGV4dCBUaGUgSFRNTCB0ZXh0IHRvIHByb2Nlc3NcbiAqIEBwYXJhbSBtZXRhZGF0YSBNZXRhZGF0YSBvYmplY3QgcHJvdmlkZWQgYnkgdGhlIGFwcGxpY2F0aW9uIGFuZCBwYXNzZWQgdGhyb3VnaCB0byBmdW5jdGlvbnNcbiAqIEBwYXJhbSBtYWhhYmh1dGFGdW5jcyBUaGUgYXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gZG9uZSBPcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZFxuICogQHJldHVybnMgVGhlIFByb21pc2UgZ2VuZXJhdGVkIGZyb20gcHJvY2Vzc0FzeW5jXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzKFxuICAgICAgICAgICAgdGV4dDogc3RyaW5nLCBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1haGFiaHV0YUZ1bmNzOiBNYWhhZnVuY0FycmF5IHwgQXJyYXk8TWFoYWZ1bmNUeXBlPixcbiAgICAgICAgICAgIGRvbmU/OiBGdW5jdGlvbikge1xuICAgIFxuICAgIGxldCByZXQgPSBwcm9jZXNzQXN5bmModGV4dCwgbWV0YWRhdGEsIG1haGFiaHV0YUZ1bmNzKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXQudGhlbihodG1sID0+IHsgZG9uZSh1bmRlZmluZWQsIGh0bWwpOyB9KVxuICAgICAgICAgICAuY2F0Y2goZXJyID0+IHsgZG9uZShlcnIpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZXh0IHVzaW5nIGZ1bmN0aW9ucyBzdXBwbGllZCBpbiB0aGUgYXJyYXkgbWFoYWJodXRhRnVuY3MuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQXN5bmMoXG4gICAgICAgICAgICAgICAgdGV4dDogc3RyaW5nLCBtZXRhZGF0YTogT2JqZWN0LFxuICAgICAgICAgICAgICAgIG1haGFiaHV0YUZ1bmNzOiBNYWhhZnVuY0FycmF5IHwgQXJyYXk8TWFoYWZ1bmNUeXBlPikge1xuXG4gICAgaWYgKCFtYWhhYmh1dGFGdW5jcyB8fCBtYWhhYmh1dGFGdW5jcy5sZW5ndGggPCAwKSBtYWhhYmh1dGFGdW5jcyA9IFtdO1xuXG4gICAgbGV0IGNsZWFuT3JEaXJ0eSA9ICdmaXJzdC10aW1lJztcblxuICAgIC8vIGNvbnNvbGUubG9nKGBwcm9jZXNzQXN5bmMgdGV4dCBhdCBzdGFydCAke3RleHR9YCk7XG5cbiAgICAvLyBBbGxvdyBhIHByZS1wYXJzZWQgY29udGV4dCB0byBiZSBwYXNzZWQgaW5cbiAgICBjb25zdCAkID0gdHlwZW9mIHRleHQgPT09ICdmdW5jdGlvbicgPyB0ZXh0IDogcGFyc2UodGV4dCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhgcHJvY2Vzc0FzeW5jICQgYXQgc3RhcnQgYCwgJC5odG1sKCkpO1xuXG4gICAgLy8gY29uc3QgbG9vcHMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIC8vIGxldCBzdGFydFByb2Nlc3NpbmcgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgbWhPYmo7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1haGFiaHV0YUZ1bmNzKSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYEFSUkFZIHN1YnN0aXR1dGlvbmApO1xuICAgICAgICAgICAgbWhPYmogPSBuZXcgTWFoYWZ1bmNBcnJheShcIm1hc3RlclwiLCB7fSk7XG4gICAgICAgICAgICBtaE9iai5zZXRNYWhhZnVuY0FycmF5KG1haGFiaHV0YUZ1bmNzKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYWhhYmh1dGFGdW5jcyBpbnN0YW5jZW9mIE1haGFmdW5jQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBNYWhhZnVuY0FycmF5YCk7XG4gICAgICAgICAgICBtaE9iaiA9IG1haGFiaHV0YUZ1bmNzO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKGBCYWQgbWFoYWJodXRhRnVuY3Mgb2JqZWN0IHN1cHBsaWVkYCk7XG5cbiAgICAgICAgY2xlYW5PckRpcnR5ID0gJ2NsZWFuJztcbiAgICAgICAgLyogbGV0IHJlc3VsdHMgPSAqLyBhd2FpdCBtaE9iai5wcm9jZXNzKCQsIG1ldGFkYXRhLCAoKSA9PiB7IGNsZWFuT3JEaXJ0eSA9ICdkaXJ0eSc7IH0pO1xuXG4gICAgICAgIC8vIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4geyBsb29wcy5wdXNoKG1oT2JqLm5hbWUgKycgICcrIHJlc3VsdCk7IH0pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgTUFIQUJIVVRBIHByb2Nlc3NBc3luYyAke21ldGFkYXRhLmRvY3VtZW50LnBhdGh9IEZJTklTSCAkeyhuZXcgRGF0ZSgpIC0gc3RhcnRQcm9jZXNzaW5nKSAvIDEwMDB9IHNlY29uZHMgJHtjbGVhbk9yRGlydHl9YCk7XG4gICAgfSB3aGlsZSAoY2xlYW5PckRpcnR5ID09PSAnZGlydHknKTtcblxuICAgIC8vIGxvb3BzLmZvckVhY2gobCA9PiB7IGNvbnNvbGUubG9nKGwpOyB9KTtcblxuICAgIHJldHVybiAkLmh0bWwoKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIG9uZSBmdW5jdGlvbiBhZ2FpbnN0IHRoZSBzdXBwbGllZCB0ZXh0LlxuICogXG4gKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBwcm9jZXNzXG4gKiBAcGFyYW0gbWV0YWRhdGEgTWV0YWRhdGEgb2JqZWN0IHByb3ZpZGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBhbmQgcGFzc2VkIHRocm91Z2ggdG8gZnVuY3Rpb25zXG4gKiBAcGFyYW0gbWFoYWZ1bmMgQSBzaW5nbGUgZnVuY3Rpb24sIG9yIGEge0BsaW5rIE1haGFmdW5jQXJyYXl9LCB0byBleGVjdXRlXG4gKiBAcGFyYW0gZG9uZSBPcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZFxuICogQHJldHVybnMgVGhlIFByb21pc2UgZ2VuZXJhdGVkIGZyb20gcHJvY2Vzc0FzeW5jXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzMShcbiAgICAgICAgICAgIHRleHQ6IHN0cmluZywgbWV0YWRhdGEsXG4gICAgICAgICAgICBtYWhhZnVuYzogTWFoYWZ1bmNUeXBlLFxuICAgICAgICAgICAgZG9uZT86IEZ1bmN0aW9uKSB7XG5cbiAgICByZXR1cm4gcHJvY2Vzcyh0ZXh0LCBtZXRhZGF0YSwgWyBtYWhhZnVuYyBdLCBkb25lKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBNYWhhZnVuY0FycmF5IFxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgZm9yIHRoZSBhcnJheVxuICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBcbiAqIEBwYXJhbSBmdW5jdGlvbnMgQW4gb3B0aW9uYWwgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYWRkXG4gKiBAcmV0dXJucyBBIE1haGFmdW5jQXJyYXlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXG4gICAgICAgIG5hbWU6IHN0cmluZywgY29uZmlnOiBPYmplY3QsIGZ1bmN0aW9ucz86IE1haGFmdW5jVHlwZSk6IE1haGFmdW5jQXJyYXkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IE1haGFmdW5jQXJyYXkobmFtZSwgY29uZmlnKTtcbiAgICBpZiAoZnVuY3Rpb25zKSBhcnJheS5hZGRNYWhhZnVuYyhmdW5jdGlvbnMpO1xuICAgIHJldHVybiBhcnJheTtcbn1cbiJdfQ==